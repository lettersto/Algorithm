// LeetCode 137. Single Number 2

// memory complexity를 O(1)을 요구하길래
// bit manipulation까지는 떠올렸지만, 그 이상은 불가능했던 문제

// 새로운 지식이 필요했던 문제

// 보통 bit 문제가 숫자가 있음을 1 없음을 0으로 표시를 했다면
// 최대 3번까지 숫자가 나타나기 때문에, 첫 번째와 두 번째는 존재해야 하고
// 세 번째 때 0으로 만드는 과정이 필요

// 이를 위해 첫 번째를 표시하는 once, 두 번째를 표시하는 twice를 둔다.
// 3번 나온 숫자는 bit가 모두 0이 되기 때문에 결과적으로 한 번만 나타나는 숫자는 once에만 존재

const singleNumber = function (nums) {
  let once = 0;
  let twice = 0;

  // 2 2 2 3 4 4 4을 bit상태로 만들어 각 자리 bit 개수를 더해본다면
  // 010
  // 010
  // 010
  // 011
  // 100
  // 100
  // 100
  // -------> 3 (2 ** 2 자리) 4 (2 ** 1 자리) 1 (2 ** 0 자리) 이 나옴
  // -------> 3번씩 나온 숫자들 끼리 더하면 bit의 각 자리의 갯수도 3의 배수가 나옴
  // -------> 그렇기 때문에 각 자리를 3으로 나눠 보면 나머지가 0 1 1로
  // -------> 혼자 한 번 나온 3이 되게 됨
  // =======> 즉, 숫자가 나온 순서에 상관 없이 각 자리가 나온 개수를 더해가면서
  // =======> 이진수 각 자리의 개수가 3배수로 돌아가는지 체크 필요

  // 그런데, 3배수 일때 bit manipulation을 단순히 숫자가 나오면 1 아니면 0으로 하기에는 어려움
  // 그래서 이 자리에서 처음 나온 비트는 once에 표기하고, 두 번째 나온 비트는 twice에 표기
  // 세 번째 나온 비트는 once와 twice 모두 0으로 돌아가면 됨

  // 각 bit 자리가 0 or 3번 나온 경우 = once 0, twice 0
  // 한 번 나온 경우 = once 1, twice = 0
  // 세 번 나온 경우 = once 0, twice = 1

  for (const num of nums) {
    // (1) once ^ num
    // a - 이미 once의 자리에 bit가 있다면 이미 한 번 나온 것이므로 삭제 필요 => 1 x 1 = 0
    // b - once에 없다면 bit 추가가 필요 => 0 x 1 = 1
    // => XOR(once, num)

    // 이때 b에서 두 번 나온 숫자라 once에 표기가 안 되어 있던 것일 수 있음
    // 그렇기 때문에 ~twice를 해 두 번째 나오지 않은 자리가 어딘지 알 수 있도록 만들고
    // 둘을 &해서 교집합만 뽑아낸다.
    once = ~twice & (once ^ num);

    // (2) twice ^ num도 (1)과 동일하다.
    // twice의 자리에 없는 것만 1로 추가, 있다면 0으로 만듦
    // 그런데 twice에 없는 게 once에 있기 때문일 수 있으니, once에 없는 숫자만 들어오도록 &
    twice = ~once & (twice ^ num);
  }

  return once;
};
